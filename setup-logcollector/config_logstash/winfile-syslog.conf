input {
    pipeline { address => [ls2winfile] }
}

filter{
    if [logtype]{
        if [logtype] == "dhcp"
        {
            # dissect {
            #     mapping => {
            #         "message" => "%{id},%{date},%{time},%{description},%{srcip},%{hostname},%{macaddress},%{user},%{transactionid},%{qresult},%{probationtime},%{correlationid},%{dhcid},%{vendorclasshex},%{vendorclassascii},%{userclasshex},%{userclassascii},%{relayagentinformation},%{dnsregerror}"
            #         "message" => "%{ID},%{Date},%{Time},%{Description},%{IP_Address},%{Host_Name},%{MAC_Address},%{User_Name},%{TransactionID},%{QResult},%{Probationtime},%{CorrelationID},%{Dhcid},%{VendorClass_hex},%{VendorClass_ascii},%{UserClass_hex},%{UserClass_ascii},%{RelayAgentInformation},%{DnsRegError}"
            #     }
            # } 
            grok {
                # Server 2008+
                match => { "message" => "%{DATA:id},%{DATE_US:date},%{DATA:time},%{DATA:description},%{IPV4:srcip},%{DATA:hostname},%{DATA:macaddress},%{DATA:user},%{INT:TransactionID},%{INT:QResult},%{DATA:ProbationTime},%{DATA:CorrelationID}"}
                # Server 2003
                match => { "message" => "%{DATA:id},%{DATE_US:date},%{DATA:time},%{DATA:description},%{IPV4:srcip},%{DATA:hostname},%{DATA:macaddress},"}
                match => { "message" => "%{DATA:id},%{DATA:date},%{DATA:Time},%{DATA:description},%{IPV4:srcip},%{DATA:hostname},%{DATA:macaddress},"}
            }
            mutate
            {
                add_field => ["app", "DHCP"]
                remove_field=> ['date', 'time']
            }
        }
        
        mutate { replace => { "host_device_type" => "%{host_device_type}_%{logtype}" } }
    }
}

output {
  pipeline { send_to => [ls2es] }
  pipeline { send_to => [ls2fs] }
#   stdout {codec => rubydebug}
}