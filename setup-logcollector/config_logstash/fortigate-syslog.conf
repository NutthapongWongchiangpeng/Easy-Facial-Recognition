input {
    pipeline { address => [ls2fortigate] }
}

filter{
    if "tcp_stream" in [tags]{
#         split {
#                 field => "message"
#                 terminator => "<189>"
# #               terminator => "^\t | ^\r | ^\n | ^\s"
#                 #add_tag => ["debug:split"]
#         }
        grok {
            match => ["message", "%{GREEDYDATA:num}%{SYSLOG5424PRI:syslog_index}%{GREEDYDATA:message}"]
            overwrite => [ "message" ]
            tag_on_failure => [ "forti_grok_failure" ]
        }
    }
    else{
        grok {
            match => ["message", "%{SYSLOG5424PRI:syslog_index}%{GREEDYDATA:message}"]
            overwrite => [ "message" ]
            tag_on_failure => [ "forti_grok_failure" ]
        }
    }
    
    kv {
        source => "message"
        value_split => "="
        field_split => " "
    }

    mutate {
        rename => { "type" => "ftg_type" }
        rename => { "subtype" => "ftg_subtype" }
        #replace => { "host_device_type" => "fortigate_%{ftg_type}" }
        convert => { "rcvdbyte" => "integer" }
        convert => { "sentbyte" => "integer" }
        convert => { "duration" => "integer" }
    }

#Configuramos Geolocalizacion:
#   		geoip {
#      			source => "srcip"
#                        target => "geosrcip"
#		      	database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
#                        add_field => [ "[geosrcip][coordinates]", "%{[geosrcip][longitude]}" ]
#                        add_field => [ "[geosrcip][coordinates]", "%{[geosrcip][latitude]}"  ]
#   		}
#                geoip {
#                        source => "dstip"
#                        target => "geodstip"
#                        database => "/opt/logstash/vendor/geoip/GeoLiteCity.dat"
#                        add_field => [ "[geodstip][coordinates]", "%{[geodstip][longitude]}" ]
#                        add_field => [ "[geodstip][coordinates]", "%{[geodstip][latitude]}"  ]
#                }
#                mutate {
#                        convert => [ "[geoip][coordinates]", "float" ]
#		 }
#                if !("_grokparsefailure" in [tags]) {
#                        mutate {
#                                replace => [ "host", "%{syslog_hostname}" ]
#                                replace => [ "@source_host", "%{syslog_hostname}" ]
#                        }
#                }

   if [srcip] and [srcip] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)" {
       geoip {
           source => "srcip"
           target => "SourceIPGeo"
       }

        # Delete 0,0 in SourceIPGeo.location if equal to 0,0
       if ([SourceIPGeo.location] and [SourceIPGeo.location] =~ "0,0") {
           mutate {
               replace => [ "SourceIPGeo.location", "" ]
            }
        }
    }

    # Geolocate logs that have DestinationIP and if that DestinationIP is a non-RFC1918 address
   if [dstip] and [dstip] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)" {
       geoip {
           source => "dstip"
           target => "DestinationIPGeo"
       }

        # Delete 0,0 in DestinationIPGeo.location if equal to 0,0
       if ([DestinationIPGeo.location] and [DestinationIPGeo.location] =~ "0,0") {
           mutate {
               replace => [ "DestinationIPGeo.location", "" ]
            }
        }
    }

#    mutate {
#        remove_field => ["syslog_index","syslog5424_pri","path",
#                        "service","date","time","sentpkt","rcvdpkt","log_id",
#                        "poluuid","wanout","devname","trandisp","priority",
#                        "proto","devid","facility","srcintfrole","dstintf",
#                        "severity","policytype","lanout","lanin","srcintf",
#                        "duration","dstintfrole","srcport","appid","countapp"]
#    }

    mutate {
        remove_field => ["syslog_index","syslog5424_pri","path",
                        "date","time","sentpkt","rcvdpkt","log_id",
                        "poluuid"]
    }
    #### Keyword matching
    #if "SSL tunnel established" in [message] or "SSL tunnel shutdow" in [message] {
    #    mutate { add_tag => "vpn_matcher" }
    #}
}

output {
  pipeline { send_to => [ls2es] }
  pipeline { send_to => [ls2fs] }
  #if "vpn_matcher" in [tags]{
  #      pipeline { send_to => [ls2http] }
  #}
#   stdout {codec => rubydebug}
#### This line for auto-reload
}